---
title: "Coding Practice Problems"
author: "Kevin Patyk"
date: "11/8/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Coding Practice Problems from CodeChef

-----

# 1 - ATM

Pooja would like to withdraw X USD from an ATM. The cash machine will only accept the transaction if X is a multiple of 5, and Pooja's account balance has enough cash to perform the withdrawal transaction (including bank charges). For each successful withdrawal the bank charges 0.50 $US. Calculate Pooja's account balance after an attempted transaction.

* Input: Positive integer 0 < X <= 2000 - the amount of cash which Pooja wishes to withdraw. Nonnegative number 0<= Y <= 2000 with two digits of precision - Pooja's initial account balance. 

* Output: Output the account balance after the attempted transaction, given as a number with two digits of precision. If there is not enough money in the account to complete the transaction, output the current bank balance.
```{r}
atm <- function(x, y){
  if(x %% 5 == 0){
    withdrawal <- y - x
    final <- round(withdrawal - 0.50, 2)
  } else {
    stop("x must be a multiple of 5")
  }
  if (x > y){
    stop(paste("Insufficient funds for withdrawal. You only have", y, "but you requested", x))
  }
  balance <- paste("Your remaining balance is:", y - final)
  return(list("Withdrawal Amount" = final, "Balance" = balance))
}

atm(x = 100, y = 120)
```

# 2 - Add Two Numbers

Shivam is the youngest programmer in the world, he is just 12 years old. Shivam is learning programming and today he is writing his first program.

The task is very simple: given two integers A and B, write a program to add these two numbers and output it.

* Input: The first line contains an integer T, the total number of test cases. Then follow T lines, each line contains two Integers A and B.

* Output: For each test case, add A and B and display the sum in a new line.

* Constraints: 1 ≤ T ≤ 1000, 0 ≤ A,B ≤ 10000
```{r}
addnums <- function(len_t, a, b){
  stopifnot(len_t >= 1, len_t <= 1000, a >= 0, b >= 0, a <= 10000, b <= 10000)
  stor <- list()[1:len_t]
  for(i in 1:len_t){
    stor[[i]] <- a[i] + b[i]
  }
  return(stor)
}

addnums(len_t = 3, a = c(1,2,3), b = c(1,2,3))
```

# 3 - Number Mirror

Write a program that accepts a number, n, and outputs the same.

* Input: The only line contains a single integer.

* Output: Output the answer in a single line.

* Constraints: 0 ≤ n ≤ 105
```{r}
mirror <- function(n){
  stopifnot(length(n) == 1)
  if(n <= 0 | n >= 10^5){
    stop("n is not within the constraints") 
  }  else {
    print(n)
  }
}

mirror(n = 1)
```

# 4 - Sum of Digits

You're given an integer N. Write a program to calculate the sum of all the digits of N.

* Input: The first line contains an integer T, the total number of testcases. Then follow T lines, each line contains an integer N.

* Output: For each test case, calculate the sum of digits of N, and display it in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ N ≤ 1000000

Here we are using: `sum(as.numeric(strsplit(x = as.character(n), split = "")[[1]]))`. This code will:

* First, it will coerce the number vector into a character vector.
* Then, it will split the character vector into separate parts. This will turn it into a list. 
* Then, it will subset the list using the first index, which will give us the numbers as splits characters.
* Finally, the numbers will be coerced into a numeric type and summed. 
```{r}
sumdigits <- function(len_t, n){
  stopifnot(len_t > 0, len_t < 1000, n > 0, n < 1000000)
  x <- lapply(X = n, FUN = function(x) sum(as.numeric(strsplit(x = as.character(n), split = "")[[1]])))
  print(x)
}

sumdigits(len_t = 3, n = c(123,123,123))

#using for loop instead of lapply()
sumdigits_for <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000, n >= 1, n <= 1000000)
  stor <- list()[1:len_t]
  for(i in 1:len_t){ 
    stor[[i]] <- sum(as.numeric(strsplit(x = as.character(n[i]), split = "")[[1]]))
  }
  return(stor)
}

sumdigits_for(len_t = 3, n = c(123,123,123))
```

# 5 - Find Remainder

Write a program to find the remainder when an integer A is divided by an integer B.

* Input: The first line contains an integer T, the total number of test cases. Then T lines follow, each line contains two Integers A and B.

* Output: For each test case, find the remainder when A is divided by B, and display it in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ A,B ≤ 10000
```{r}
remainder <- function(len_t, a, b){
  stopifnot(len_t >= 1, len_t <= 1000, a >= 0, b >= 0, a <= 10000, b <= 10000)
  stor <- list(1:len_t)
  for(i in 1:len_t){
    stor[[i]] <- a[i] %% b[i]
  }
  return(stor)
}

remainder(len_t = 3, a = c(10,5,3), b = c(6,4,2))
```

# 6 - First and Last Digit 

If Give an integer N . Write a program to obtain the sum of the first and last digits of this number.

* Input: The first line contains an integer T, the total number of test cases. Then follow T lines, each line contains an integer N.

* Output: For each test case, display the sum of first and last digits of N in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ N ≤ 1000000
```{r}
firlasdig <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000, n >= 1, n <= 1000000)
  stor <- list()[1:len_t]
  for(i in 1:len_t){
    split <- as.numeric(strsplit(x = as.character(n[i]), split = "")[[1]])
    stor[[i]] <- (split[1] + split[length(split)])
  }
  return(stor)
}

firlasdig(len_t = 3, n = c(123, 123, 123))
```

Instead of `x[length(x)]`, we can also do:

* `tail(x, n=1)`
* `x[end(x)][1]`
* `rev(x)[1]`

# 7 - Lucky Four

Kostya likes the number 4 much. Of course! This number has such a lot of properties.

Impressed by the power of this number, Kostya has begun to look for occurrences of four anywhere. He has a list of T integers, for each of them he wants to calculate the number of occurrences of the digit 4 in the decimal representation. He is too busy now, so please help him.

* Input: The first line of input consists of a single integer T, denoting the number of integers in Kostya's list.
Then, there are T lines, each of them contain a single integer from the list.

* Output: Output T lines. Each of these lines should contain the number of occurences of the digit 4 in the respective integer from Kostya's list.

* Constraints: 1 ≤ T ≤ 10^5
```{r}
luckyfour <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 10^5)
  stor <- list()[1:len_t]
  for(i in 1:len_t){
  split <- as.numeric(strsplit(x = as.character(n[i]), split = "")[[1]])
  stor[[i]] <- length(split[split == 4])
  }
  return(stor)
}

luckyfour(len_t = 4, n = c(1234, 445566, 7444, 555))
```

# 8 - Small Factorials

You are asked to calculate factorials of some small positive integers.

* Input: An integer t, 1 <= t <= 100, denoting the number of test cases, followed by t lines, each containing a single integer n, 1 <= n <= 100.

* Output: For each integer n given at input, display a line with the value of n!
```{r}
smallfac <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 100, n >= 1, n <= 100)
  stor <- list()[1:len_t]
  for(i in 1:len_t){
    stor[[i]] <- factorial(n[i])
  }
  return(stor)
}

smallfac(len_t = 5, n = c(4,1,2,5,3))
```

# 9 - Turbo Sort

Given the list of numbers, you are to sort them in non decreasing order.

* Input: t – the amount of numbers in list, then t lines follow [t <= 10^6]. Each line contains one integer: 0 <= n <= 10^6

* Output: Output given numbers in non decreasing order.
```{r}
turbosort <- function(len_t, n){
  stopifnot(len_t <= 10^6, n >= 0, n <= 10^6)
  stor <- list()[1:len_t]
  sorted <- sort(n)
  for(i in 1:len_t){
    stor[[i]] <- sorted[i]
  }
  return(stor)
}

turbosort(len_t = 6, c(6,3,2,4,5,1))
```

# 10 - Reverse the Number

Given an Integer N, write a program to reverse it.

* Input: The first line contains an integer T, total number of testcases. Then follow T lines, each line contains an integer N.

* Output: For each test case, display the reverse of the given number N in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ N ≤ 1000000
```{r}
reverseint <- function(len_t, n){
  stopifnot(len_t >= 1,len_t <= 1000, n >= 0, n <= 1000000)
  stor <- list()[1:len_t]
  for(i in 1:len_t){
    split <- as.numeric(strsplit(x = as.character(n[i]), split = "")[[1]])
    stor[[i]] <- as.numeric(paste(rev(split), collapse = ""))
  }
  return(stor)
}

reverseint(len_t = 3, n = c(123,123,123))
```

# 11 - Finding Square Roots

Assume that you happen to hear the above words and you want to give a try in finding the square root of any given integer using in-built functions. So here's your chance.

* Input: The first line of the input contains an integer T, the number of test cases. T lines follow. Each line contains an integer N whose square root need to be computed.

* Output: For each line of the input, output the square root of the input integer, rounded down to the nearest integer, in a new line.

* Constraints: 1<=T<=20, 1<=N<=10000
```{r}
fsq <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 20, n >= 1, n <= 10000)
  stor <- list()
  for(i in 1:len_t){
    stor[[i]] <- floor(sqrt(n[i]))
  }
  return(stor)
}

fsq(len_t = 4, n = c(3, 10, 5, 10000))
```

# 12 - Second Largest

Three numbers A, B and C are the inputs. Write a program to find second largest among them.

* Input: The first line contains an integer T, the total number of test cases. Then T lines follow, each line contains three integers A, B and C.

* Output: For  each test case, display the second largest among A, B and C, in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ A,B,C ≤ 1000000
```{r}
seclarg <- function(len_t, a, b, c){
  stopifnot(len_t >= 1, len_t <= 1000, a >= 1, b >= 1, c >= 1, a <= 1000000, b <= 1000000, c <= 1000000)
  stor <- list()
  for(i in 1:len_t){
    vec <- sort(c(a[i], b[i], c[i]))
    stor[[i]] <- vec[which.max(vec) - 1]
  }
  return(stor)
}

seclarg(len_t = 3, a = c(5,5,5), b = c(1,1,1), c = c(100, 100, 100))
```

# 13 - The Lead Game

* Input: The first line of the input will contain a single integer N (N ≤ 10000) indicating the number of rounds in the game. Lines 2,3,...,N+1 describe the scores of the two players in the N rounds. Line i+1 contains two integer Si and Ti, the scores of the Player 1 and 2 respectively, in round i. You may assume that 1 ≤ Si ≤ 1000 and 1 ≤ Ti ≤ 1000.

* Output: Your output must consist of a single line containing two integers W and L, where W is 1 or 2 and indicates the winner and L is the maximum lead attained by the winner.
```{r}
leadgame <- function(n, p1, p2){
  cumscorep1 <- cumsum(p1)
  cumscorep2 <- cumsum(p2)
  diffp1 <- cumscorep1 - cumscorep2
  diffp2 <- cumscorep2 - cumscorep1
  if(max(diffp1) > max(diffp2)){
  return(c(1, max(diffp1)))  
  } else {
  return(c(2, max(diffp2)))
  }
}

leadgame(n = 5, p1 = c(140, 89, 90, 112, 88), p2 = c(82, 133, 110, 106, 90))
```

# 14 - Helping Chef

Write a program, which takes an integer N and if the number is less than 10 then display "Thanks for helping Chef!" otherwise print "-1".

* Input: The first line contains an integer T, total number of test cases. Then follow T lines, each line contains an integer N.

* Output: For each test case, output the given string or -1 depending on conditions, in a new line.

* Constraints: 1 ≤ T ≤ 1000, -20 ≤ N ≤ 20
```{r}
helpchef <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000, n >= -20, n <= 20)
  for(i in 1:len_t){
  if(n[i] < 10){
    print("Thanks for helping Chef!")
  } else{
    print("-1")
    }
  }
}

helpchef(len_t = 3, n = c(-10, 19, 5))
```

# 15 - Chef and Operators

Chef has just started Programming, he is in first year of Engineering. Chef is reading about Relational Operators.
Relational Operators are operators which check relationship between two values. Given two numerical values A and B you need to help chef in finding the relationship between them that is,

* First one is greater than second or,
* First one is less than second or,
* First and second one are equal.

* Input: First line contains an integer T, which denotes the number of testcases. Each of the T lines contain two integers A and B

* Output: For each line of input produce one line of output. This line contains any one of the relational operators
'<' , '>' , '='.

* Constraints: 1 ≤ T ≤ 10000, 1 ≤ A, B ≤ 1000000001
```{r}
chefop <- function(len_t, a, b){
  stopifnot(len_t >= 1, len_t <= 10000, a >= 1, a <= 1000000001, b >= 1, b <= 1000000001)
  for(i in 1:len_t){
    if(a[i] > b[i]){
      print(">")
    } else if(a[i] < b[i]){
      print("<")
    } else{
      print("=")
    }
  }
}

chefop(len_t = 3, a = c(10,20,10), b = c(20,10,10))
```

# 16 - Packaging Cupcakes

Now that Chef has finished baking and frosting his cupcakes, it's time to package them. Chef has N cupcakes, and needs to decide how many cupcakes to place in each package. Each package must contain the same number of cupcakes. Chef will choose an integer A between 1 and N, inclusive, and place exactly A cupcakes into each package. Chef makes as many packages as possible. Chef then gets to eat the remaining cupcakes. Chef enjoys eating cupcakes very much. Help Chef choose the package size A that will let him eat as many cupcakes as possible.

* Input: Input begins with an integer T, the number of test cases. Each test case consists of a single integer N, the number of cupcakes.

* Output: For each test case, output the package size that will maximize the number of leftover cupcakes. If multiple package sizes will result in the same number of leftover cupcakes, print the largest such size.

* Constraints: 1 ≤ T ≤ 1000, 2 ≤ N ≤ 100000000 (10^8)
```{r}
packcup <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000, n >= 2, n <= 10^8)
  for(i in 1:len_t){
    print(n[i] %/% 2+1)
  }
}

#%/% is integer division, the same as floor(n/m) - integer division discards the remainder; %% is the remainder  

packcup(len_t = 2, n = c(2,5))
```

# 17 - Valid Triangles

Write a program to check whether a triangle is valid or not, when the three angles of the triangle are the inputs. A triangle is valid if the sum of all the three angles is equal to 180 degrees.

* Input: The first line contains an integer T, the total number of test cases. Then T lines follow, each line contains three angles A, B and C, of the triangle separated by space.

* Output: For each test case, display 'YES' if the triangle is valid, and 'NO', if it is not, in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ A,B,C ≤ 180
```{r}
validtri <- function(len_t, a, b, c){
  stopifnot(len_t >= 1, len_t <= 1000, a >= 1, a <= 180, b >= 1, b <= 180, c >= 1, c <= 180)
  for(i in 1:len_t){
  if(sum(a[i] + b[i] + c[i]) > 180){
    print("NO")
  } else {
    print("Yes")
    }
  }
}

validtri(len_t = 3, a = c(40, 45, 180), b = c(40, 45, 1), c = c(100, 90, 1))
```

# 18 - Chef and Remissness 

The office where the Chef works, has two guards who count how many times a person enters into the office building. Though the duty of a guard is 24 hours in a day, sometimes they fall asleep during their duty and do not track the entry of a person in the office building. But one good thing is that they never fall asleep at the same time. At least one of them remains awake and counts who enters into the office.


Now the boss of Chef wants to calculate how many times the Chef has entered into the building. The boss asked to the guard and they gave him two integers A and B, the count of first guard and second guard respectively.


Help the boss to count the minimum and maximum number of times Chef could have entered into the office building.

* Input: The first line of the input contains an integer T denoting the number of test cases. The description of the T test cases follows.

Each test case consists of a line containing two space separated integers A and B.

* Output: For each test case, output a single line containing two space separated integers, the minimum and maximum number of times Chef could have entered into the office building.

* Constraints: 1 ≤ T ≤ 100, 0 ≤ A, B ≤ 1000000
```{r}
chefremiss <- function(len_t, a, b){
  stopifnot(len_t >= 1, len_t <= 100, a >= 0, b >= 0, a <= 1000000, b <= 1000000)
  for(i in 1:len_t){
    print(c(a[i], a[i]+ b[i]))
  }
}

chefremiss(len_t = 3, a = c(19, 14, 17), b = c(17, 14, 10))
```

# 19 - Decrement or Increment 

Write a program to obtain a number N and increment its value by 1 if the number is divisible by 4 otherwise decrement its value by 1.

* Input: First line will contain a number N.

* Output: Output a single line, the new value of the number.

* Constraints:0 ≤ N ≤ 1000
```{r}
decorin <- function(n){
  stopifnot(n >= 0, n <= 1000)
  if(n %% 4 == 0){
    print(n + 1)
  } else {
    print(n - 1)
  }
}

decorin(n = 5)
```

# 20 - Mahasena 

Kattapa, as you all know was one of the greatest warriors of his time. The kingdom of Maahishmati had never lost a battle under him (as army-chief), and the reason for that was their really powerful army, also called as Mahasena.

Kattapa was known to be a very superstitious person. He believed that a soldier is "lucky" if the soldier is holding an even number of weapons, and "unlucky" otherwise. He considered the army as "READY FOR BATTLE" if the count of "lucky" soldiers is strictly greater than the count of "unlucky" soldiers, and "NOT READY" otherwise.

Given the number of weapons each soldier is holding, your task is to determine whether the army formed by all these soldiers is "READY FOR BATTLE" or "NOT READY".

* Input: The first line of input consists of a single integer N denoting the number of soldiers. The second line of input consists of N space separated integers A1, A2, ..., AN, where Ai denotes the number of weapons that the ith soldier is holding

* Output: Generate one line output saying "READY FOR BATTLE", if the army satisfies the conditions that Kattapa requires or "NOT READY" otherwise (quotes for clarity)

* Constraints: 1 ≤ N ≤ 100, 1 ≤ Ai ≤ 100
```{r}
battle <- function(n = a, a){
  stopifnot(n >= 1, n <= 100, a >= 1, a <= 100)
  if(sum(a %% 2 == 0) > sum(a %% 2 != 0)){
    print("READY FOR BATTLE")
  } else {
    print("NOT READY")
  }
}

battle(a = c(11:14))
```

# 21 - Sum or Difference

Write a program to take two numbers as input and print their difference if the first number is greater than the second number otherwise print their sum.

* Input: First line will contain the first number (N1), Second line will contain the second number (N2)

* Output: Output a single line containing the difference of 2 numbers (N1−N2) if the first number is greater than the second number otherwise output their sum (N1+N2).

* Constraints: −1000 ≤ N1 ≤ 1000, −1000 ≤ N2 ≤ 1000
```{r}
sumdiff <- function(n1, n2){
  stopifnot(n1 >= -1000, n1 <= 1000, n2 >= -1000, n2 <= 1000)
  if(n1 > n2){
    print(n1 - n2)
  } else{
    print(n1 + n2)
  }
}

sumdiff(n1 = 82, n2 = 28)
```

# 22 - Smallest Numbers of Notes

Consider a currency system in which there are notes of six denominations, namely, Rs. 1, Rs. 2, Rs. 5, Rs. 10, Rs. 50, Rs. 100. If the sum of Rs. N is input, write a program to computer smallest number of notes that will combine to give Rs. N.

* Input: The first line contains an integer T, total number of test cases. Then follow T lines, each line contains an integer N

* Output: For each test case, display the smallest number of notes that will combine to give N, in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ N ≤ 1000000
```{r}
snn <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000, n >= 1, n <= 1000000)
  den <- c(100, 50, 10, 5, 2, 1)
  x <- numeric()
  for(i in 1:length(n)){ #first for loop to run the same number of times as length n 
  n[i] <- n[i] #this will make a vector containing the n values
  x[i] <- 0 #this will make a vector containing 0s and the same length as the vector of n values - it will end up holding how many notes go into a particular number 
  for(j in 1:length(den)){ #now we will make a for loop to iterate over the den vector - will iterate 6 times
  x[i] <- x[i] + (n[i] %/% den[j]) #how many times the denomination goes into n - so, if 100 goes into 242 2 times, it will store this in the x vector 
  n[i] <- n[i] %% den[j] #the remainder of n after removing the previous denomination - so, if 100 goes into 242 2 times, that is 242 - 100, so 42 will be the new n
}
  }
  return(x)
}

snn(len_t = 3, n = c(1200, 500, 242))
```

# 23 - The Block Game

The citizens of Byteland regularly play a game. They have blocks each denoting some integer from 0 to 9. These are arranged together in a random manner without seeing to form different numbers keeping in mind that the first block is never a 0. Once they form a number they read in the reverse order to check if the number and its reverse is the same. If both are same then the player wins. We call such numbers palindrome.

Ash happens to see this game and wants to simulate the same in the computer. As the first step he wants to take an input from the user and check if the number is a palindrome and declare if the user wins or not.

* Input: The first line of the input contains T, the number of test cases. This is followed by T lines containing an integer N.

* Output: For each input output "wins" if the number is a palindrome and "loses" if not, in a new line.

* Constraints: 1<=T<=20, 1<=N<=20000
```{r}
palindrome <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 20, n >= 1, n <= 20000)
  stor <- list()
  for(i in 1:len_t){
    if(identical(as.character(n[i]), paste(rev(strsplit(as.character(n[i]), "")[[1]]), collapse= ""))){
      stor[[i]] <- "wins"
    } else{
      stor[[i]] <- "loses"
    }
  }
    return(stor)
}

palindrome(len_t = 3, n = c(331, 666, 343))
```

# 24 - Primality Test

Alice and Bob are meeting after a long time. As usual they love to play some math games. This times Alice takes the call and decides the game. The game is very simple, Alice says out an integer and Bob has to say whether the number is prime or not. Bob as usual knows the logic but since Alice doesn't give Bob much time to think, so Bob decides to write a computer program.

Help Bob accomplish this task by writing a computer program which will calculate whether the number is prime or not .

* Input: The first line of the input contains an integer T, the number of test cases. T lines follow. Each of the next T lines contains an integer N which has to be tested for primality. 

* Output: For each test case output in a separate line, "yes" if the number is prime else "no."

* Constraints: 1 ≤ T ≤ 20, 1 ≤ N ≤ 100000
```{r}
# & and && indicate logical AND and | and || indicate logical OR. The shorter form performs element wise comparisons in much the same way as arithmetic operators. The longer form evaluates left to right examining only the first element of each vector. Evaluation proceeds only until the result is determined.
primecheck <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 20, n >= 1, n <= 100000)
  stor <- list()
  for(i in 1:len_t){
    if(n[i] <= 1 | n[i] %% 2 == 0 | n[i] %% 3 == 0){
      stor[[i]] <- "no"
    } else if( n[i] == 2 | n[i] == 3 | n[i] == 5 | n[i] == 7){
      stor[[i]] <- "yes"
    } else{
      for(j in c(2, (n %/% 2) + 1)){
        if(n[i] %% j == 0){
          stor[[i]] <- "no"
        } else{
          stor[[i]] <- "yes"
        }
      }
    }
  }   
  return(stor)
}

primecheck(len_t = 5, n = c(23, 13, 20, 1000, 99991))
```

# 25 - Ship and ID

Write a program that takes in a letterclass ID of a ship and display the equivalent string class description of the given ID. Use the table below.

* CLass ID: B or b, C or c, D or d, F or f; Ship Class: Battleship, Cruiser, Destroyer, Frigate.

* Input: The first line contains an integer T, the total number of test cases. Then T lines follow, each line contains a character.

* Output: For each test case, display the Ship Class depending on ID, in a new line.

* Constraints: 1 ≤ T ≤ 1000
```{r}
shipid <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000)
  stor <- list()
  for(i in 1:len_t){
    if(n[i] == "B" | n[i] == "b"){
      stor[[i]] <- "Battleship"
    } else if(n[i] == "C" | n[i] == "c"){
      stor[[i]] <- "Cruiser"
    } else if(n[i] == "D" | n[i] == "d"){
      stor[[i]] <- "Destroyer"
    } else if(n[i] == "F" | n[i] == "f"){
      stor[[i]] <- "Frigate"
    } else{
      stop(paste("Incorrect input for:", n[i]))
    }
  }
  return(stor)
}

shipid(len_t = 3, n = c("B", "c", "D"))
```

# 25 - Puppy and Sum

Yesterday, puppy Tuzik learned a magically efficient method to find the sum of the integers from 1 to N. He denotes it as sum(N). But today, as a true explorer, he defined his own new function: sum(D, N), which means the operation sum applied D times: the first time to N, and each subsequent time to the result of the previous operation.

For example, if D = 2 and N = 3, then sum(2, 3) equals to sum(sum(3)) = sum(1 + 2 + 3) = sum(6) = 21.

Tuzik wants to calculate some values of the sum(D, N) function. Will you help him with that?

* Input: The first line contains a single integer T, the number of test cases. Each test case is described by a single line containing two integers D and N.

* Output: For each test case, output one integer on a separate line.

* Constraints: 1 ≤ T ≤ 16, 1 ≤ D, N ≤ 4
```{r}
puppysum <- function(len_t, d, n){
  stopifnot(len_t >= 1, len_t <= 16, d >= 1, n <= 4)
  x <- numeric()
  for(i in 1:len_t){
    if(d[i] == 1){
      x[i] <- sum(1:n[i])
    } else {
      x[i] <- n[i] 
      for(j in d){ #since the d vector can contain multiple numbers, only the number that is entering the for loop after the else statement will be used. So, if d[i] = 1, then it will stay one; but if d[i] == 2, then it will run the for loop after the else statement 2 times, until d becomes 0.
      while(d[i] > 0){
      x[i] <- sum(1:max(x[i]))
      d[i] <- d[i] - 1
      }
    }
  }
}
  return(x)
}

puppysum(len_t = 2, d = c(1, 2), n = c(4, 3))
```

# 26 - GCD and LCM

Two integers A and B are the inputs. Write a program to find GCD and LCM of A and B.

* Input: The first line contains an integer T, total number of testcases. Then follow T lines, each line contains an integer A and B.

* Output: Display the GCD and LCM of A and B separated by space respectively. The answer for each test case must be displayed in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ A,B ≤ 1000000
```{r}
gcdlcm <- function(len_t, a, b){
  stopifnot(len_t >= 1, len_t <= 1000, a >= 1, b >= 1, a <= 1000000, b <= 1000000)
  gcd <- numeric()
  lcm <- numeric()
  for(i in 1:len_t){
  if(a[i] > b[i]) {
  smaller <- b[i]
} else {
  smaller <- a[i]
} 
    for(j in 1:smaller){
    if(a[i] %% j == 0 & b[i] %% j == 0){
    gcd[i] <- j
    }
  }
  lcm[i] <- ((a[i] %/% gcd[i]) * (b[i] %/% gcd[i]) * gcd[i])
  }
  return(data.frame(gcd, lcm))
}  

gcdlcm(len_t = 3, a = c(120, 10213, 10), b = c(140, 312, 30))
```

# 27 - Total Expenses

While purchasing certain items, a discount of 10% is offered if the quantity purchased is more than 1000. If the quantity and price per item are input, write a program to calculate the total expenses.

* Input: The first line contains an integer T, total number of test cases. Then follow T lines, each line contains integers quantity and price.

* Output: For each test case, output the total expenses while purchasing items, in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ quantity,price ≤ 100000
```{r}
totalexp <- function(len_t, q, p){
  stopifnot(len_t >= 1, len_t <= 1000, q >= 1, p >= 1, q <= 100000, p <= 100000)
  stor <- list()
  for(i in 1:len_t){
    if(q[i] > 1000){
      stor[[i]] <- (q[i]*p[i]) - (.10*(q[i]*p[i]))
    } else{
      stor[[i]] <- (q[i]*p[i])
    }
  }
  return(stor)
}

totalexp(len_t = 3, q = c(100, 10, 1200), p = c(120, 20, 20))
```

# 28 - Gross Salary 

In a company an emplopyee is paid as under: If his basic salary is less than Rs. 1500, then HRA = 10% of base salary and DA = 90% of basic salary. If his salary is either equal to or above Rs. 1500, then HRA = Rs. 500 and DA = 98% of basic salary. If the Employee's salary is input, write a program to find his gross salary.

Note: Gross Salary = Basic Salary + HRA + DA

* Input: The first line contains an integer T, total number of test cases. Then follow T lines, each line contains an integer salary.

* Output: For each test case, output the gross salary of the employee in a new line. Your answer will be considered correct if the absolute error is less than 10-2.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ salary ≤ 100000
```{r}
grosssal <- function(len_t, sal){
  stopifnot( len_t >= 1, len_t <= 1000, sal >= 1, sal <= 100000)
  stor <- list()
  for(i in 1:len_t){
    if(sal[i] < 1500){
      stor[[i]] <- sal[i] + (.10*sal[i]) + (.90*sal[i])
    } else{
      stor[[i]] <- sal[i] + 500 + (.98*sal[i])
    }
  }
  return(stor)
}

grosssal(len_t = 3, sal = c(1203, 10042, 1312))
```

# 29 - Grade the Steel

A certain type of steel is graded according to the following conditions.

Hardness of the steel must be greater than 50
Carbon content of the steel must be less than 0.7
Tensile strength must be greater than 5600
The grades awarded are as follows:

* Grade is 10 if all three conditions are met
* Grade is 9 if conditions (1) and (2) are met
* Grade is 8 if conditions (2) and (3) are met
* Grade is 7 if conditions (1) and (3) are met
* Grade is 6 if only one condition is met
* Grade is 5 if none of the three conditions are met

Write a program to display the grade of the steel, based on the values of hardness, carbon content and tensile strength of the steel, given by the user.

* Input: The first line contains an integer T, total number of test cases. Then follow T lines, each line contains three numbers hardness, carbon content and tensile strength of the steel.

* Output: For each test case, print Grade of the steel depending on conditions, in a new line.

* Constraints: 1 ≤ T ≤ 1000, 0 ≤ hardness, carbon content, tensile strength ≤ 10000
```{r}
steelgrade <- function(len_t, h, c, s){
  stopifnot(len_t >= 1, len_t <= 1000, h >= 0, c >= 0, s >= 0, h <= 10000, c <= 10000, s <= 10000)
  stor <- list()
  for(i in 1:len_t){
    if(h[i] > 50 & c[i] < 0.7 & s[i] > 5600){
    stor[[i]] <- "Grade 10"
    } else if (h[i] > 50 & c[i] < 0.7){
    stor[[i]] <- "Grade 9"
    } else if (c[i] < 0.7 & s[i] > 5600){
    stor[[i]] <- "Grade 8"
    } else if(h[i] > 50 & s[i] > 5600){
    stor[[i]] <- "Grade 7"
    } else if(h[i] > 50 | c[i] < 0.7 | s[i] > 5600){
    stor[[i]] <- "Grade 6"
    } else{
    stor[[i]] <- "Grade 5"
  }
  }
  return(stor)
}

steelgrade(len_t = 3, h = c(53, 45, 0), c = c(0, 0.6, 0), s = c(5602, 4500, 0))
```

# 30 - Two vs Ten

Chef Two and Chef Ten are playing a game with a number X. In one turn, they can multiply X by 2. The goal of the game is to make X divisible by 10.

Help the Chefs find the smallest number of turns necessary to win the game (it may be possible to win in zero turns) or determine that it is impossible.

* Input: The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows. The first and only line of each test case contains a single integer denoting the initial value of X.

* Output: For each test case, print a single line containing one integer — the minimum required number of turns or −1 if there is no way to win the game.

* Constraints: 1 ≤ T ≤ 1000, 0 ≤ X ≤ 109
```{r}
twovten <- function(len_t, x){
  stopifnot(len_t >= 1, len_t <= 1000, x >= 0, x <= 109)
  stor <- list()
  for(i in 1:len_t){
    if(x[i] %% 10 == 0){
      stor[[i]] <- 0
    } else if(x[i] %% 5 != 0){
      stor[[i]] <- -1
    } else {
      stor[[i]] <- 1 
    }
  }
  return(stor)
}

twovten(len_t = 3, x = c(10, 25, 1))
```

# 31 - Rectangle

You are given four integers a, b, c and d. Determine if there's a rectangle such that the lengths of its sides are a, b, c and d (in any order).

* Input: The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows. The first and only line of each test case contains four space-separated integers a, b, c and d.

* Output: For each test case, print a single line containing one string "YES" or "NO".

* Constraints: 1 ≤ T ≤ 1,000, 1 ≤ a, b, c, d ≤ 10,000
```{r}
rectangle <- function(len_t, a, b, c, d){
  stopifnot(len_t >= 1, len_t <= 1000, a >= 1, b >= 1, c >= 1, d > 1, a <= 10000, b <= 10000, c <= 10000, d <= 10000)
  stor <- list()
  for(i in 1:len_t){
    vec <- sort(c(a[i], b[i], c[i], d[i]))
    if(vec[1] == vec[2] & vec[3] == vec[4]){
      stor[[i]] <- "YES"
    } else{
      stor[[i]] <- "NO"
    }
  }
  return(stor)
}

rectangle(len_t = 3, a = c(1,3,1), b = c(1,2,2), c = c(2,2,2), d = c(2,3,2))
```


# 32 - Is it a VOWEL or CONSONANT

Write a program to take a character (C) as input and check whether the given character is a vowel or a consonant.

NOTE: Vowels are 'A', 'E', 'I', 'O', 'U'. Rest all alphabets are called consonants.

* Input: First line will contain the character C

* Output: Print "Vowel" if the given character is a vowel, otherwise print "Consonant".

* Constraints: C will be an upper case English  alphabet
```{r}
vowcon <- function(C){
  stor <- list()
  for(i in 1:length(C)){
    if(C[i] != toupper(C[i])){
      stop("Input must be an upper case.")
    } else{
      if(C[i] == "A" | C[i] == "E" | C[i] == "I" | C[i] == "O" | C[i] == "U"){
        stor[[i]] <- "Vowel"
      } else{
        stor[[i]] <- "Consonant"
      }
    }
  }
  return(stor)
}

vowcon(C = c("Z", "A", "C", "I"))
```


# 33 - Chef and Fruits 

Today is Chef's birthday. His mom has surprised him with truly fruity gifts: 2 fruit baskets. The first basket contains N apples, and the second one contains M oranges. Chef likes apples and oranges very much but he likes them equally, and therefore, wants to have the minimum possible difference between the number of apples and oranges he has. To do so, he can purchase 1 apple or 1 orange by paying exactly 1 gold coin (that's some expensive fruit, eh?). Chef can purchase fruits at most K times (as he has only K gold coins in his pocket) to make the difference the minimum possible.

Our little Chef is busy in celebrating his birthday to the fullest, and therefore, he has handed this job to his best friend — you. Can you help him by finding the minimum possible difference he can achieve between the number of apples and orange he owns?

* Input: The first line of input contains a single integer T denoting the number of test cases. The first and only line of each test case contains 3 space separated integers — N, M and K — denoting the number of apples, number of oranges, and number of gold coins our little Chef has

* Output: For each test case, output the minimum possible difference between the number of apples and oranges that Chef can achieve.

* Constraints: 1 ≤ T ≤ 100, 1 ≤ N, M, K ≤ 100
```{r}
mindiff <- function(len_t, n, m, k){
  stopifnot(len_t >= 1, len_t <= 100, n >= 1, m >= 1, k >= 1, n <= 100, m <= 100, k <= 100)
  stor <- list()
  for(i in 1:len_t){
  maxi <- max(c(n[i], m[i]))
  mini <- min(c(n[i], m[i]))
  stor[[i]] <- maxi - min(c(mini + k[i], maxi))
  }
  return(stor)
}

mindiff(len_t = 3, n = c(3,5,3), m = c(4,2,4), k = c(1,1,3))
```

# 34 - Area OR Perimeter

Write a program to obtain length (L) and breadth (B) of a rectangle and check whether its area is greater or perimeter is greater or both are equal.

* Input: Write a program to obtain length (L) and breadth (B) of a rectangle and check whether its area is greater or perimeter is greater or both are equal. Second line will contain the breadth (B) of the rectangle.

* Output: Output 2 lines. In the first line print "Area" if area is greater otherwise print "Peri" and if they are equal print "Eq".(Without quotes). In the second line print the calculated area or perimeter (whichever is greater or anyone if it is equal).

* Constraints: 1 ≤ L ≤ 1000, 1 ≤ B ≤ 1000
```{r}
areaperi <- function(L, B){
  stopifnot(L >= 1, L <= 1000, B >= 1, B <= 1000)
  stor <- character()
  res <- numeric()
  for(i in 1:length(L)){
    area <- (L[i]*B[i])
    perimeter <- 2*(L[i]+B[i])
    if(area > perimeter){
      stor[i] <- "Area"
      res[i] <- area
    } else {
      stor[i] <- "perimeter"
      res[i] <- perimeter
    } 
  }
  return(data.frame(stor, res))
}

areaperi(L = c(1,3,5), B = c(2,4,6))
```

# 35 - HOW MANY DIGITS DO I HAVE

Write a program to obtain a number (N) from the user and display whether the number is a one digit number, 2 digit number, 3 digit number or more than 3 digit number.

* Input: First line will contain the number  N

* Output: Print "1" if N is a 1 digit number. Print "2" if N is a 2 digit number. Print "3" if N is a 3 digit number. Print "More than 3 digits" if N has more than 3 digits.

* Constraints: 0 ≤ N ≤ 1000000
```{r}
hmd <- function(n){
  stopifnot(n >= 0, n <= 1000000)
  digits <- numeric()
  numb <- numeric()
  for(i in 1:length(n)){
    n[i] <- as.character(n[i])
    digits[i] <- nchar(n[i])
    numb[i] <- as.numeric(n[i])
  }
  return(data.frame(numb, digits))
}

hmd(n = c(333, 222))
```

# 36 - Coins And Triangle

Chef belongs to a very rich family which owns many gold mines. Today, he brought N gold coins and decided to form a triangle using these coins. Isn't it strange?

Chef has a unusual way of forming a triangle using gold coins, which is described as follows:

* He puts 1 coin in the 1st row.
* Then puts 2 coins in the 2nd row.
* Then puts 3 coins in the 3rd row.
* And so on.

Chef is interested in forming a triangle with maximum possible height using at most N coins. Can you tell him the maximum possible height of the triangle?

* Input: The first line of input contains a single integer T denoting the number of test cases. The first and the only line of each test case contains an integer N denoting the number of gold coins Chef has.

* Output: For each test case, output a single line containing an integer corresponding to the maximum possible height of the triangle that Chef can get.

* Constraints: 1 ≤ T ≤ 100, 1 ≤ N ≤ 10^9
```{r}
tricoin <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 100, n >= 1, n <= 10^9)
  stor <- list()
  a <- integer()
  for(i in 1:len_t){
    for(j in 1:(n[i]+2)){
      a[i] <- j *(j + 1) %/% 2
        if(a[i] > n[i]){
          stor[[i]] <- (j - 1)
          break
      }
    }
  }
  print(stor)
}

tricoin(len_t = 3, n = c(3,5,7))
```

# 37 - Mutated Minions 

Gru has not been in the limelight for a long time and is, therefore, planning something particularly nefarious. Frustrated by his minions' incapability which has kept him away from the limelight, he has built a transmogrifier — a machine which mutates minions

Each minion has an intrinsic characteristic value (similar to our DNA), which is an integer. The transmogrifier adds an integer K to each of the minions' characteristic value.

Gru knows that if the new characteristic value of a minion is divisible by 7, then it will have Wolverine-like mutations.

Given the initial characteristic integers of N minions, all of which are then transmogrified, find out how many of them become Wolverine-like.

* Input: The first line contains one integer, T, which is the number of test cases. Each test case is then described in two lines. The first line contains two integers N and K, as described in the statement. The next line contains N integers, which denote the initial characteristic values for the minions.

* Output: For each test case, output one integer in a new line, which is the number of Wolverine-like minions after the transmogrification.

* Constraints: 1 ≤ T ≤ 100, 1 ≤ N ≤ 100, 1 ≤ K ≤ 100
```{r}
transmog <- function(len_t, n, k){
  stopifnot(len_t >= 1, len_t <= 100, n >= 1, n <= 100, k >= 1, k <= 100)
  new_n <- n + k
  count <- sum(new_n %% 7 == 0)
  return(count)
}

transmog(len_t = 5, n = c(2,4,1,35,1), k = 10)
```
# 38 - Bear and Candies 123

You are given a string. Your task is to determine whether number of occurrences of some character in the string is equal to the sum of the numbers of occurrences of other characters in the string. 

* Input: The first line of the input contains an integer T denoting the number of test cases. Each of the next T lines contains one string S consisting of lowercase latin letters. 

* Output: For each test case, output a single line containing "YES" if the string satisfies the condition given above or "NO" otherwise.

* Constraints: 1 <= T <= 1000, 1 <= S <= 50 
```{r}

```

-----

# End of document

-----

```{r}
sessionInfo()
```

